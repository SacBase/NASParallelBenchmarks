import StdIO: all;
import Math: all;
import Array: all;

/*
 * The following defines are needed for "telling" the compiler 
 * all possible input sizes. For more information see "main".
 */

#define S0 2
#define S1 4
#define S2 8
#define S3 16
#define S4 32
#define S5 64
#define S6 128
#define S7 256


/*
 * The following flags are used to create different versions:
 * DISTRIB_LAW_BUG_IS_FIXED indicates whether the compiler is capable
 *   to apply distributive law (1) or not (0).
 * USE_SAME_SHORTCUT_AS_IN_FORTRAN indicates whether the algorithm patch
 *   used in the Fortran version of the benchmark in order to spare one
 *   copy of the largest array should be applied in SAC as well (1) or not (0).
 */

#define DISTRIB_LAW_BUG_IS_FIXED 1
#define USE_SAME_SHORTCUT_AS_IN_FORTRAN 1

/* 
 * Now, we define the arrays of weights needed for relaxation (A),
 * restriction (P), extension (Q), and smoothing (S).
 * In the NAS-MG benchmark, all these have a particular property:
 * weights with the same "distance" from the "center" do have the same
 * value! Therefore, in the 3-dimensional case, they can be described
 * by a vector containing 4 values: 
 * [ center, distance 1, distance 2, distance 3]
 *
 * Another consequence of this property is that for the computation
 * of the required weighted sums the distributive law is applicable,
 * which leads to a noticable speedup in program execution.
 * Since the FORTRAN program is hand-optimized to this effect,
 * we have to make sure that the distributive law optimization
 * of the SAC compiler is turned on!
 */

#define AP [ -8d/3d, 0d    , 1d/6d  , 1d/12d]
#define PP [ 1d/2d , 1d/4d , 1d/8d  , 1d/16d]
#define QP [ 1d    , 1d/2d , 1d/4d  , 1d/8d ]
#define SP [ -3d/8d, 1d/32d, -1d/64d, 0d    ]

#define SHP [3,3,3]

#if DISTRIB_LAW_BUG_IS_FIXED

#define A gen_weights( AP)
#define P gen_weights( PP)
#define Q gen_weights( QP)
#define S gen_weights( SP)

inline double[+] gen_weights( double[+] wp)
{
  res = with {
          ( . <= iv <= . )
          : off = with {
                    ( 0*shape(iv) <= ix < shape(iv) )
                    {
                      if ( iv[ix] != 1 )
                        dist = 1;
                      else
                        dist = 0;
                    } : dist;
                  } : fold( +, 0 );
        } : genarray( SHP, wp[[off]] );

  return( res);
}
#else

/*
 * Since the actual SAC2C compiler due to a bug does not support
 * distributive law optimization, a modified version of the function
 * that computes the weighted sums ("weighted_sum") has to be used
 * which is hand optimized to that effect.
 * As a consequence, A, P, Q, and S are not arrays of weights of shape
 * SHP, but are only the carriers of different values needed for the
 * particularities of the NAS-MG benchmark.
 */

#define A AP
#define P PP
#define Q QP
#define S SP

#endif


double l2norm( double[+] u)
{
  sqrsum = with {
             ( 0*shape(u) <= x < shape(u) ) : u[x]*u[x];
           } : fold( +, 0d );
  n_elem = with {
             ( [0] <= y < [dim(u)] ) : tod( shape(u)[y] );
           } : fold( *, 1d );

  return( sqrt( sqrsum/n_elem));
}





#if DISTRIB_LAW_BUG_IS_FIXED

inline double[+] relax_kernel( double[+] w, double[+] u)
{
  res = with {
          ( 0*shape(w) <= dx < shape(w) ) : rotate( dx-1, u ) * w[dx];
        } : fold( +, genarray( shape(u), 0d ) );

  return(res);
}

#else

inline
double[+] relax_kernel( double[+] w, double[+] u)
{  return(  sel([0],w) * u
         + sel([1],w) * ( rotate( 0, 1, u) + rotate( 0, -1, u)
                      + rotate( 1, 1, u) + rotate( 1, -1, u)
                      + rotate( 2, 1, u) + rotate( 2, -1, u))
         + sel([2],w) * ( rotate( [1,1,0], u) + rotate( [-1,-1,0], u)
                      + rotate( [0,1,1], u) + rotate( [0,-1,-1], u)
                      + rotate( [1,0,1], u) + rotate( [-1,0,-1], u)
                      + rotate( [-1,1,0], u) + rotate( [1,-1,0], u)
                      + rotate( [0,-1,1], u) + rotate( [0,1,-1], u)
                      + rotate( [-1,0,1], u) + rotate( [1,0,-1], u))
         + sel([3],w) * ( rotate( [1,1,1], u) + rotate( [-1,-1,-1], u)
                      + rotate( [-1,1,1], u) + rotate( [1,-1,-1], u)
                      + rotate( [1,-1,1], u) + rotate( [-1,1,-1], u)
                      + rotate( [1,1,-1], u) + rotate( [-1,-1,1], u) ) );
}

#endif


inline
double[+] relax( double[+] u, double[+] v)
{
  r = v - relax_kernel( A, u);
  return(r);
}

inline
double[+] smooth( double[+] z, double[+] r)
{
  z = z + relax_kernel( S, r);
  return( z);
}

inline
double[+] smooth( double[+] r)
{
  z = relax_kernel( S, r);
  return( z);
}

#if 0
/* requiers WLIR (included in ssa opts) */
inline
double[+] fine2coarse( double[+] r)
{
  rn = with {
         ( . <= x <= . ) : relax_kernel( P, r )[2*x+1];
       } : genarray( shape(r) / 2 );

  return(rn);
}

#else
/* manual wlir... */
inline
double[+] fine2coarse( double[+] r)
{
  lir_lift = relax_kernel( P, r);

  rn = with {
         ( . <= x <= . ) : lir_lift[2*x+1];
       } : genarray( shape(r) / 2, 0d );

  return(rn);
}
#endif

inline
double[+] coarse2fine( double[+] rn)
{
  r = with {
        ( 0*shape(rn)+1 <= iv < 2*shape(rn) step 0*shape(rn)+2 ) : rn[(iv-1)/2];
      } : genarray( 2*shape(rn), 0d );
  
  r = relax_kernel( Q, r);
  return(r);
}



inline
double[+] mgrid( double[+] r)
{ /*
   * non-coarsest grid: r(k-1) = P r(k)			(fine2coarse)
   *                    z(k-1) = M(k-1) r(k-1)		(recursive solve)
   *                    z(k)   = Q z(k-1)		(coarse2fine)
   *                    r(k)   = r(k) - A z(k)		(relax)
   *                    z(k)   = z(k) + S r(k)          (smooth)
   */
  rn = fine2coarse( r);
  zn = mgrid( rn);
  z  = coarse2fine( zn);
  r  = relax( z, r);
  z  = smooth( z, r);

  return(z);
}

inline
double[S0,S0,S0] mgrid( double[S0,S0,S0] r)
{
  z = smooth( r);
  return( z);
}

double nas_mgrid( double[+] u, double[+] v, int[+] pos, int[+] neg, int iter)
{
  for( i=0; i<10; i++)
    v = modarray( v, neg[[i]] - 1, -1d);

  for( i=0; i<10; i++)
    v = modarray( v, pos[[i]] - 1, 1d);

  r = relax( u, v);

  i = 0;

  do {

#if USE_SAME_SHORTCUT_AS_IN_FORTRAN
    rn = fine2coarse(r);
    zn = mgrid(rn);
    u  = u + coarse2fine(zn);
    r  = relax(u, v);
    u  = smooth(u, r);
#else
    u  = u + mgrid( r);
#endif


    r  = relax( u, v);

    i += 1;
  }
  while( i<iter);

  z = l2norm( r);
  return(z);
}

specialize
double nas_mgrid( double[S0, S0, S0] u, double[S0, S0, S0] v,
                  int [10, 3] pos     , int[10, 3] neg, int iter );
specialize
double nas_mgrid( double[S1, S1, S1] u, double[S1, S1, S1] v,
                  int [10, 3] pos     , int[10, 3] neg, int iter );
specialize
double nas_mgrid( double[S2, S2, S2] u, double[S2, S2, S2] v,
                  int [10, 3] pos     , int[10, 3] neg, int iter );
specialize
double nas_mgrid( double[S3, S3, S3] u, double[S3, S3, S3] v,
                  int [10, 3] pos     , int[10, 3] neg, int iter );
specialize
double nas_mgrid( double[S4, S4, S4] u, double[S4, S4, S4] v,
                  int [10, 3] pos     , int[10, 3] neg, int iter );
specialize
double nas_mgrid( double[S5, S5, S5] u, double[S5, S5, S5] v,
                  int [10, 3] pos     , int[10, 3] neg, int iter );
specialize
double nas_mgrid( double[S6, S6, S6] u, double[S6, S6, S6] v,
                  int [10, 3] pos     , int[10, 3] neg, int iter );
specialize
double nas_mgrid( double[S7, S7, S7] u, double[S7, S7, S7] v,
                  int [10, 3] pos     , int[10, 3] neg, int iter );


/*
 * The tricky part of this program is that we want to run the same
 * executable on different array sizes without re-compilation.
 * Since the current compiler only accepts programs where all
 * shapes involved can be determined statically, we have to use
 * a nesting of conditionals in order to force the compiler
 * to generate the variants we are interested in.
 */
int main()
{
  int[10,3] pos;
  int[10,3] neg;

  size = (int) FibreScanIntArray();
  iter = (int) FibreScanIntArray();
  pos  = (int[10, 3]) FibreScanIntArray();
  neg  = (int[10, 3]) FibreScanIntArray();

  u = genarray([size,size,size], 0d);

  v = genarray([size,size,size], 0d);

  z = nas_mgrid(u, v, pos, neg, iter);

  printf( " L2-Norm after %d iteration(s) with max. grid [%d,%d,%d]: %.10e\n", 
          iter, size, size, size, z);

  return( 0);
}


